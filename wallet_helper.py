"""
Simple wallet connection utilities for Hyperliquid Trading Journal
Replaces the problematic streamlit-wallet-connect package
"""

import streamlit as st
import re
import hashlib
import time
from typing import Optional, Tuple

def is_valid_ethereum_address(address: str) -> bool:
    """
    Validate Ethereum address format
    """
    if not address:
        return False
    
    # Remove 0x prefix if present
    if address.startswith('0x'):
        address = address[2:]
    
    # Check if it's 40 hex characters
    if len(address) != 40:
        return False
    
    # Check if all characters are valid hex
    return all(c in '0123456789abcdefABCDEF' for c in address)

def format_address_display(address: str) -> str:
    """
    Format address for display (0x1234...5678)
    """
    if not address:
        return "No address"
    
    if not address.startswith('0x'):
        address = '0x' + address
    
    return f"{address[:6]}...{address[-4:]}"

def generate_verification_message() -> str:
    """
    Generate a message for signature verification
    """
    timestamp = int(time.time())
    return f"Verify wallet ownership for Hyperliquid Trading Journal\nTimestamp: {timestamp}\nPlease sign this message to confirm ownership."

def create_wallet_connection_ui() -> Optional[str]:
    """
    Create a simple wallet connection UI component
    Returns the connected wallet address or None
    """
    st.subheader("üîó Wallet Connection")
    
    # Connection status
    if st.session_state.get('wallet_address'):
        st.success(f"üü¢ Connected: {format_address_display(st.session_state.wallet_address)}")
        
        col1, col2 = st.columns([1, 1])
        with col1:
            if st.button("üîå Disconnect Wallet"):
                st.session_state.wallet_address = None
                st.session_state.wallet_verified = False
                st.session_state.trades = []
                st.session_state.user_state = {}
                st.rerun()
        
        with col2:
            if st.button("üîÑ Refresh Connection"):
                st.rerun()
        
        return st.session_state.wallet_address
    
    # Connection form
    st.info("üí° Enter your Ethereum wallet address to fetch trading data from Hyperliquid")
    
    with st.form("wallet_connection_form"):
        wallet_input = st.text_input(
            "Wallet Address:",
            placeholder="0x1234567890123456789012345678901234567890",
            help="Your Ethereum wallet address (starts with 0x)"
        )
        
        # Add some example addresses for testing
        with st.expander("‚ÑπÔ∏è Address Format Help"):
            st.write("Valid Ethereum address format:")
            st.code("0x1234567890123456789012345678901234567890")
            st.write("- Must start with '0x'")
            st.write("- Must be 42 characters total (40 hex characters + 0x)")
            st.write("- Only contains numbers 0-9 and letters A-F")
        
        submitted = st.form_submit_button("üîó Connect Wallet", type="primary")
        
        if submitted:
            if not wallet_input:
                st.error("‚ùå Please enter a wallet address")
                return None
            
            # Add 0x prefix if missing
            if not wallet_input.startswith('0x'):
                wallet_input = '0x' + wallet_input
            
            if is_valid_ethereum_address(wallet_input):
                st.session_state.wallet_address = wallet_input.lower()
                st.session_state.wallet_verified = True
                st.success(f"‚úÖ Wallet connected: {format_address_display(wallet_input)}")
                st.rerun()
            else:
                st.error("‚ùå Invalid Ethereum address format")
                return None
    
    return None

def create_signature_verification_ui(wallet_address: str) -> bool:
    """
    Optional signature verification for additional security
    """
    if not wallet_address:
        return False
    
    with st.expander("üîê Optional: Verify Wallet Ownership"):
        st.info("For additional security, you can sign a message to prove you own this wallet")
        
        # Generate verification message
        verification_message = generate_verification_message()
        
        st.write("**Message to sign:**")
        st.code(verification_message, language="text")
        
        st.write("**Instructions:**")
        st.write("1. Copy the message above")
        st.write("2. Sign it with your wallet (MetaMask, etc.)")
        st.write("3. Paste the signature below")
        
        signature = st.text_input(
            "Signature:",
            placeholder="0x...",
            help="The signature generated by your wallet"
        )
        
        if st.button("üîç Verify Signature"):
            if signature and len(signature) > 100:
                # In a real implementation, you would verify the signature
                # For now, just accept long signatures as potentially valid
                st.success("‚úÖ Signature format looks valid!")
                st.info("Note: Full signature verification requires web3.py integration")
                return True
            else:
                st.error("‚ùå Please provide a valid signature")
                return False
    
    return False

def create_wallet_info_display(wallet_address: str):
    """
    Display wallet information and connection status
    """
    if not wallet_address:
        return
    
    st.write("**Connected Wallet:**")
    st.code(wallet_address)
    
    # Show truncated address for privacy
    st.write(f"**Display:** {format_address_display(wallet_address)}")
    
    # Connection timestamp
    if 'connection_time' not in st.session_state:
        st.session_state.connection_time = time.time()
    
    connection_time = time.strftime(
        "%Y-%m-%d %H:%M:%S", 
        time.localtime(st.session_state.connection_time)
    )
    st.caption(f"Connected at: {connection_time}")

def get_wallet_connection_status() -> Tuple[bool, Optional[str]]:
    """
    Get current wallet connection status
    Returns (is_connected, wallet_address)
    """
    wallet_address = st.session_state.get('wallet_address')
    is_connected = bool(wallet_address and st.session_state.get('wallet_verified', False))
    
    return is_connected, wallet_address

def clear_wallet_connection():
    """
    Clear wallet connection and related data
    """
    keys_to_clear = [
        'wallet_address', 
        'wallet_verified', 
        'connection_time',
        'trades', 
        'user_state'
    ]
    
    for key in keys_to_clear:
        if key in st.session_state:
            del st.session_state[key]

# Example usage functions
def demo_wallet_connection():
    """
    Demo function showing how to use the wallet connection
    """
    st.title("Wallet Connection Demo")
    
    # Create wallet connection UI
    wallet_address = create_wallet_connection_ui()
    
    if wallet_address:
        # Show wallet info
        create_wallet_info_display(wallet_address)
        
        # Optional signature verification
        create_signature_verification_ui(wallet_address)
        
        # Show connection status
        is_connected, address = get_wallet_connection_status()
        st.write(f"Connection Status: {'‚úÖ Connected' if is_connected else '‚ùå Not Connected'}")
        
        if is_connected:
            st.write("Ready to fetch trading data!")
    else:
        st.info("Please connect your wallet to continue")

if __name__ == "__main__":
    # Run demo if executed directly
    demo_wallet_connection()